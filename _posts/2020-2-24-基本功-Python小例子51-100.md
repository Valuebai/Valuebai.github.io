---
layout:     post					# 使用的布局（不需要改）
title:      基本功-Python小例子51-100		# 标题
subtitle:   鱼每天都练习基本功，台上十分钟台下十年功，编程写代码或许也需要这样子的，就用python小例子来练习吧    			#副标题
date:       2020-2-24
author:     Valuebai
header-img: img/bg_common.jpg 	#这篇文章标题背景图片
catalog: true
tags:
    - Python
---

## 51 查看对象类型

```
class Student(object):
    def __init__(self, id, name):
        self.id = id
        self.name = name

    def __repr__(self):
        return 'id=' + self.id + ', name=' + self.name
		
xiaoming = Student(id='001',name='xiaoming')
print(type(xiaoming))
-><class '__main__.Student'>

type(tuple())
->tuple

```



## 52 聚合迭代器ZIP
```
# 创建一个聚合了来自每个可迭代对象中的元素的迭代器：
x = [3, 2, 1]
y = [4, 5, 6]

print(list(zip(y, x)))

a = range(5)
b = list('abcde')

print(b)
print([str(y) + str(x) for x, y in zip(a, b)])

```

## 53 nonlocal 用于内嵌函数中

```
# 关键词 nonlocal 常用于函数嵌套中，声明变量 i 为非局部变量；
# 如果不声明，i+=1 表明 i 为函数 wrapper 内的局部变量，因为在 i+=1 引用(reference) 时,i 未被声明，所以会报 unreferenced variable 的错误。
import time


def exceter(f, n):
    i = 0
    t1 = time.time()

    def wrapper():
        try:
            f()
        except Exception as e:
            nonlocal i
            i += 1
            print(f'{e.args[0]}:{i}')
            t2 = time.time()
            if i == n:
                print(f'spending time:{round(t2 - t1, 2)}')

    return wrapper

```

## 54 global 声明全局变量

```
# 先回答为什么要有 global，一个变量被多个函数引用，想让全局变量被所有函数共享。有的伙伴可能会想这还不简单，这样写：
i = 5
def f():
	print(i)
def g():
	print(i)
	pass
	
f()
g()

```

f 和 g 两个函数都能共享变量 i，程序没有报错，所以他们依然不明白为什么要用global.
但是，如果我想要有个函数对 i 递增，这样：
```
def h():
i += 1
h()
```
此时执行程序，bang, 出错了！抛出异常：UnboundLocalError，原来编译器在解释 i+=1 时会把 i 解析为函数 h() 内的局部变量，很显然在此函数内，编译器找不到对变量 i 的定义，所以会报错。

global 就是为解决此问题而被提出，在函数 h 内，显示地告诉编译器 i 为全局变量，然后编译器会在函数外面寻找 i 的定义，执行完 i+=1 后，i 还为全局变量，值加 1：
```
i = 0
def h():
global i i += 1
h()
print(i)
```


## 55 链式比较
```
i = 3
print(1 < i < 3) # False
print(1 < i <= 3) # True
```


## 56 不用else和if实现计算器
```
from operator import *

def calulator(a, b, k):
	return{
		'+': add,
		'-': sub,
		'/': mul,
		'**': pow
	}[k](a,b)
	
calulator(1, 2, '+') # 3
calulator(3, 4, '**') # 81


```


## 57 链式操作
```
from operator import (add, sub)

def add_or_sub(a, b, oper):
	return (add if oper == '+' else sub)(a, b)
	
add_or_sub(1, 2, '-') # -1

```

## 58 交换两元素
```
def swap(a, b)
	return b, a
	
print(swap(1, 0))	# (0, 1)

```


## 59 去最求平均
```
def score_mean(lst):
	lst.sort()
	lst2 = lst[1:(len(lst)-1)]
	
	return round((sum(lst2)/len(lst2)), 1)
	
lst=[9.1, 9.0,8.1, 9.7, 19,8.2, 8.6,9.8]
score_mean(lst) # 9.1

```

## 60 打印99乘法表
打印出如下格式的乘法表
```
1*1=1 
1*2=2 2*2=4 
1*3=3 2*3=6 3*3=9 
1*4=4 2*4=8 3*4=12 4*4=16
1*5=5 2*5=10 3*5=15 4*5=20 5*5=25
1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36
1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49
1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64
1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 ␣ ,→9*9=81
```
一共有 10 行，第 i 行的第 j 列等于：j*i，
其中, i 取值范围：1<=i<=9
j 取值范围：1<=j<=i
根据例子分析的语言描述，转化为如下代码：

```
for i in range(1, 10):
	for j in range(1, i+1):
		print('%d * %d = %d' %(j,i,j*i), end='\t')
	print()
```


## 61 全展开
```
# 对于如下数组：
[[[1,2,3],[4,5]]]

如何完全展开成一维的。这个小例子实现的flatten是递归版，两个参数分别表示带展开的数组，输出数组。

from collections.abc import *

def flatten(lst, out_lst=None):
	if out_lst is None:
		out_lst = []
	for i in lst:
		if isinstance(i, Iterable):	#判断 i 是否可迭代
			flatten(i, out_lst)	#尾数递归
		else:
			out_lst.append(i)	# 产生结果
	
	return out_lst
	
#调用flatten:
print(flatten([[1,2,3],[4,5]]))
print(flatten([[1,2,3],[4,5]], [6,7]))
print(flatten([[[1,2,3],[4,5,6]]]))
```

## 62 列表等分
```
from math import ceil


def divide(lst, size):
    if size <= 0:
        return [lst]
    return [lst[i * size: (i + 1) * size] for i in range(0, ceil(len(lst) / size))]


r = divide([1, 3, 5, 7, 9], 2)
print(r)

-> [[1, 3], [5, 7], [9]]


r = divide([1, 3, 5, 7, 9], 2)
print(r)

-> [[1, 3, 5, 7, 9]]

```

## 63 列表压缩-过滤空的
```
def filter_false(lst):
	return list(filter(bool, lst))
	
r = filter_false([None, 0, False, '', [], 'ok', [1,2]])
print(r)

```

## 64 最长的列表是哪个
```
def max_length(*lst):
	return max(*lst, key=lambda v: len(v))
	
r = max_length([1,2,3], [4,5,6,7], [8])
print(f'更长的列表是{r}')

-> 更长的列表是[4, 5, 6, 7]

```


## 65 求众数
```
def top1(lst):
    return max(lst, default='列表为空', key=lambda v: lst.count(v))


lst = [1, 3, 3, 2, 1, 1, 2]
r = top1(lst)
print(f'{lst}中出现次数最多的元素为：{r}')

-》 [1, 3, 3, 2, 1, 1, 2]中出现次数最多的元素为：1
```

## 66 多表之最
```
def max_lists(*lst):
	return max(max(*lst, key=lambda v : max(v)))
	
r = max_lists([1,2,3], [6,7,8], [4,5])
print(r)
->8

```


## 67 列表查重
```
def has_duplicates(lst):
	return len(lst) == len(set(lst))
	
x = [1,1,2,2,3,2,3,4,5,6]
y = [1,2,3,4,5]
has_duplicates(x) # False
has_duplicates(y) # True


```


## 68 列表反转
```
def reverse(lst):
    return lst[::-1]


x = [1, 1, 2, 2, 3, 2, 3, 4, 5, 6]
print(reverse(x))

-》 [6, 5, 4, 3, 2, 3, 2, 2, 1, 1]

```

## 69 浮点数等差数列
```
def rang(start, stop, n):
    start, stop, n = float('%.2f' % start), float('%.2f' % stop), int('%.d' % n)
    step = (stop - start) / n
    lst = [start]
    while n > 0:
        start, n = start + step, n - 1
        lst.append(round((start), 2))
    return lst




r = rang(1, 8, 10)
print(r)

C:\Python36\python.exe C:/mycode/awesome-python-io/run_test_code/run_基本功_python小例子.py
[1.0, 1.7, 2.4, 3.1, 3.8, 4.5, 5.2, 5.9, 6.6, 7.3, 8.0]
```


## 70 按条件分组
```
def bif_by(lst, f):
    return [[x for x in lst if f(x)], [x for x in lst if not f(x)]]


records = [25, 89, 31, 34]
r = bif_by(records, lambda x: x < 80)
print(r)
-》 [[25, 31, 34], [89]]

```

## 71 map 实现向量运算
```
# 多序列运算函数-map(fuction, iterabel, iterabel2)
lst1 = [1, 2, 3, 4, 5, 6]
lst2 = [3, 4, 5, 6, 3, 2]
r = list(map(lambda x, y: x * y + 1, lst1, lst2))
print(r)

C:\Python36\python.exe C:/mycode/awesome-python-io/run_test_code/run_基本功_python小例子.py
[4, 9, 16, 25, 16, 13]

```

## 72 值最大的字典
```
def max_pairs(dic):
    if len(dic) == 0:
        return dic
    max_val = max(map(lambda v: v[1], dic.items()))
    return [item for item in dic.items() if item[1] == max_val]


r = max_pairs({'a': -10, 'b': 5, 'c': 3, 'd': 5})
print(r)
C:\Python36\python.exe C:/mycode/awesome-python-io/run_test_code/run_基本功_python小例子.py
[('b', 5), ('d', 5)]

```


## 23 查看变量所占字节数
```
import sys
a = {'a':1, 'b':2.0}
sys.getsizeof(a)


240


```


## 24 过滤器
```
# 在函数中设定过滤条件，迭代元素，保留返回值为True的元素：
fil = filter(lamda x: x>10,[1,11,2,45,7,6,13])
list(fil)


[11,45,13]

```

## 25 转为浮点类型
```
# 将一个整数或数值型字符串转换为浮点数
float(3)

3.0

如果不能转为浮点数，会报ValueError:
比如: float('a')

```


## 26 字符串格式化
```
# 格式化输出字符串，format(value, formatspec)实质上是调用了value的 ***for-mat*(formatspec)方法。
print("i am {0}, age{1}".format("tom",18))

i am tom, age18

```


## 27 冻结集合
```
# 创建一个不可修改的集合，因为不可修改，所以没有像set那样的add和pop方法
frozenset([1,1,3,2,3])


frozenset({1, 2, 3})

```


## 28 动态获取对象属性
```
# 获取对象属性
class Student(object):
    def __init__(self, id, name):
        self.id = id
        self.name = name

    def __repr__(self):
        return 'id=' + self.id + ', name=' + self.name


xiaoming = Student(id='001', name='xiaoming')
getattr(xiaoming, 'name') # 获取xiaoming这个实例的name属性值


```


## 29 对象是否有这个属性
```
class Student(object):
    def __init__(self, id, name):
        self.id = id
        self.name = name

    def __repr__(self):
        return 'id=' + self.id + ', name=' + self.name


xiaoming = Student(id='001', name='xiaoming')
hasattr(xiaoming, 'name')
->True

hasattr(xiaoming, 'phone')
->False

```


## 30 返回对象的哈希值
```
# 返回对象的哈希值，值得注意的是自定义的实例都是可哈希的，list,dict,set等可变对象都是不可哈希的
hash(xiaoming)
->6139638

hash([1,2,3])
->报错


```


## 31 一键帮助
```
# 返回对象的帮助文档
help(xiaoming)

```


## 32 对象门牌号
```
# 返回对象的内存地址
id(xiaoming)


```


## 33 获取用户输入
```
# 获取用户输入内容
input('请输入')

```


## 34 转为整型
```
# int(x, base=10), x可能为字符串或数值，将x转换为一个普通整数。如果参数是字符串，那么它可能包含符号和小数点。如果超出了普通整数的表示范围，一个长整数被返回。
int('12', 16)
->18


```


## 35 isinstance
```
# 判断object是否为类classinfo的实例，是返回True
class Student(object):
    def __init__(self, id, name):
        self.id = id
        self.name = name

    def __repr__(self):
        return 'id=' + self.id + ', name=' + self.name


xiaoming = Student(id='001', name='xiaoming')

isinstance(xiaoming, Student)
->True

```


## 36 父子关系鉴定
```
class undergraduate(Student):
    def studyClass(self):
        pass
    def attendActivity(self):
        pass

print(issubclass(undergraduate, Student))
-> True

issubclass(object, Student)
-> False

issubclass(Student, object)
-> True

# 如果class是classinfo元组中某个元素的子类，也会返回True
issubclass(int, (int, float))
-> True

```

## 37 创建迭代器类型
```
# 使用iter(obj, sentinel)，返回一个可迭代对象，sentinel可省略（一旦迭代到此元素，立即终止）
lst = [1, 3, 5]

for i in iter(lst):
    print(i)
	
	
class TestIter(object):
    def __init__(self):
        self.l = [1, 3, 2, 3, 4, 5]
        self.i = iter(self.l)

    def __call__(self):  # 定义了__call__ 方法的类的实例是可调用的
        item = next(self.i)
        print("__call__ is called, fowhich would return", item)
        return item

    def __iter__(self):  # 支持迭代协议（即定义有__iter__() 函数
        print("__iter__ is called")
        return iter(self.i)


t = TestIter()
print(t())

for e in TestIter():
    print(e)

```

## 38 所有对象之根
```
#object 是所有类的基类
o = object()
type(0)
->object


```


## 39 打开文件
```
# 用with oepn()，不用open()


```


## 40 次幂
```
# base 为底的exp次幂，如果mod给出，取余
pow(3,2,4)  # 3的2次幂，取4的余数
->1

```



## 41 打印
```
lst = [1,3,5]

print(lst)

print('lst:', lst)

print(f'key:{lst}'})

print('lst:{}'.format(lst))

```

## 42 创建属性的两种方式
```
# 返回property属性，典型的用法：
class C:
	def __init__(self):
		self._x = None
	def getx(self):
		return self._x
	def setx(self, value):
		self._x = value
	def delx(self):
		del self._x
	
	#使用property 类创建property属性
	x = property(getx, setx, delx, "I'm the 'x' property")
	
```

使用python装饰器，实现与上面的代码是一样效果的
```
# 返回property属性，典型的用法：
class C:
	def __init__(self):
		self._x = None
		
	@property
	def x(self):
		return self._x
		
	@x.setter
	def x(self, value):
		self._x = value
		
	@x.deleter
	def delx(self):
		del self._x

	
```


## 43 创建range序列
```
# 1）range(stop)
# 2）range(start, stop[,step])
# 生成一个不可变序列
range(11)
->range(0,11)

range(0,11,1)
->range(0,11)

```

## 44 反向迭代器
```
rev = reversed([1,4,2,3,1])
for i in rev:
	print(i)

```

## 45 四舍五入
```
# 四舍五入，ndigits 代表小数点后保留几位：
round(10.0232323232, 3)
-> 10.023

```

## 46 转为集合类型
```
# 返回一个set对象， 集合内不允许有重复元素：
a = [1,4,2,3,1]
set(a)

->{1,2,3,4}

```

## 47 转为切片对象
```
# class slice(start, stop[, step])
# 返回一个表示由range(start, stop, step)所指定索引集的slice对象，它让代码可读性、可维护性变好。
a = [1,4,2,3,1]
my_slice_meaning = slice(0.5.2)
a[my_slice_meaning]

->[1,2,1]

```

## 48 拿来就用的排序函数
```
a = [1,4,2,3,1]

sorted(a, reverse=True)
-> [4,3,2,1,1]

a = [
    {
        'name': 'xiaoming',
        'age': 18,
        'gender': 'male',

    },
    {
        'name': 'xiaohong',
        'age': 11,
        'gender': 'female',
    }

]
a = sorted(a, key=lambda x: x['age'], reverse=False)
print(a)


->[{'name': 'xiaohong', 'age': 11, 'gender': 'female'}, {'name': 'xiaoming', 'age': 18, 'gender': 'male'}]

```

## 49 求和函数
```
a = [1,4,2,3,1]

sum(a)
->11

sum(a,10)
->21

```

## 50 转元组
```
# tuple() 将对象转为一个不可变的序列类型

i_am_list = [1,3,5]
i_am_tuple = tuple(i_am_list)
print(i_am_tuple)
->(1,3,5)

```



【环境】
win10_x64 + python3.6.5


【Me】
https://github.com/Valuebai/
https://valuebai.github.io/

【参考】
1、出处：https://github.com/jackzhenguo/python-small-examples