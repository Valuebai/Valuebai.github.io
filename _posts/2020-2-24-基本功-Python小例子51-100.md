---
layout:     post					# 使用的布局（不需要改）
title:      基本功-Python小例子51-100		# 标题
subtitle:   鱼每天都练习基本功，台上十分钟台下十年功，编程写代码或许也需要这样子的，就用python小例子来练习吧    			#副标题
date:       2020-2-24
author:     Valuebai
header-img: img/bg_common.jpg 	#这篇文章标题背景图片
catalog: true
tags:
    - Python
---

## 51 查看对象类型

```
class Student(object):
    def __init__(self, id, name):
        self.id = id
        self.name = name

    def __repr__(self):
        return 'id=' + self.id + ', name=' + self.name
		
xiaoming = Student(id='001',name='xiaoming')
print(type(xiaoming))
-><class '__main__.Student'>

type(tuple())
->tuple

```



## 52 聚合迭代器ZIP
```
# 创建一个聚合了来自每个可迭代对象中的元素的迭代器：
x = [3, 2, 1]
y = [4, 5, 6]

print(list(zip(y, x)))

a = range(5)
b = list('abcde')

print(b)
print([str(y) + str(x) for x, y in zip(a, b)])

```

## 53 nonlocal 用于内嵌函数中

```
# 关键词 nonlocal 常用于函数嵌套中，声明变量 i 为非局部变量；
# 如果不声明，i+=1 表明 i 为函数 wrapper 内的局部变量，因为在 i+=1 引用(reference) 时,i 未被声明，所以会报 unreferenced variable 的错误。
import time


def exceter(f, n):
    i = 0
    t1 = time.time()

    def wrapper():
        try:
            f()
        except Exception as e:
            nonlocal i
            i += 1
            print(f'{e.args[0]}:{i}')
            t2 = time.time()
            if i == n:
                print(f'spending time:{round(t2 - t1, 2)}')

    return wrapper

```

## 54 global 声明全局变量

```
# 先回答为什么要有 global，一个变量被多个函数引用，想让全局变量被所有函数共享。有的伙伴可能会想这还不简单，这样写：
i = 5
def f():
	print(i)
def g():
	print(i)
	pass
	
f()
g()

```

f 和 g 两个函数都能共享变量 i，程序没有报错，所以他们依然不明白为什么要用global.
但是，如果我想要有个函数对 i 递增，这样：
```
def h():
i += 1
h()
```
此时执行程序，bang, 出错了！抛出异常：UnboundLocalError，原来编译器在解释 i+=1 时会把 i 解析为函数 h() 内的局部变量，很显然在此函数内，编译器找不到对变量 i 的定义，所以会报错。

global 就是为解决此问题而被提出，在函数 h 内，显示地告诉编译器 i 为全局变量，然后编译器会在函数外面寻找 i 的定义，执行完 i+=1 后，i 还为全局变量，值加 1：
```
i = 0
def h():
global i i += 1
h()
print(i)
```


## 55 链式比较
```
i = 3
print(1 < i < 3) # False
print(1 < i <= 3) # True
```


## 56 不用else和if实现计算器
```
from operator import *

def calulator(a, b, k):
	return{
		'+': add,
		'-': sub,
		'/': mul,
		'**': pow
	}[k](a,b)
	
calulator(1, 2, '+') # 3
calulator(3, 4, '**') # 81


```


## 57 链式操作
```
from operator import (add, sub)

def add_or_sub(a, b, oper):
	return (add if oper == '+' else sub)(a, b)
	
add_or_sub(1, 2, '-') # -1

```

## 58 交换两元素
```
def swap(a, b)
	return b, a
	
print(swap(1, 0))	# (0, 1)

```


## 59 去最求平均
```
def score_mean(lst):
	lst.sort()
	lst2 = lst[1:(len(lst)-1)]
	
	return round((sum(lst2)/len(lst2)), 1)
	
lst=[9.1, 9.0,8.1, 9.7, 19,8.2, 8.6,9.8]
score_mean(lst) # 9.1

```

## 60 打印99乘法表
打印出如下格式的乘法表
```
1*1=1 
1*2=2 2*2=4 
1*3=3 2*3=6 3*3=9 
1*4=4 2*4=8 3*4=12 4*4=16
1*5=5 2*5=10 3*5=15 4*5=20 5*5=25
1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36
1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49
1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64
1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 ␣ ,→9*9=81
```
一共有 10 行，第 i 行的第 j 列等于：j*i，
其中, i 取值范围：1<=i<=9
j 取值范围：1<=j<=i
根据例子分析的语言描述，转化为如下代码：

```
for i in range(1, 10):
	for j in range(1, i+1):
		print('%d * %d = %d' %(j,i,j*i), end='\t')
	print()
```


## 61 全展开
```
# 对于如下数组：
[[[1,2,3],[4,5]]]

如何完全展开成一维的。这个小例子实现的flatten是递归版，两个参数分别表示带展开的数组，输出数组。

from collections.abc import *

def flatten(lst, out_lst=None):
	if out_lst is None:
		out_lst = []
	for i in lst:
		if isinstance(i, Iterable):	#判断 i 是否可迭代
			flatten(i, out_lst)	#尾数递归
		else:
			out_lst.append(i)	# 产生结果
	
	return out_lst
	
#调用flatten:
print(flatten([[1,2,3],[4,5]]))
print(flatten([[1,2,3],[4,5]], [6,7]))
print(flatten([[[1,2,3],[4,5,6]]]))
```

## 62 列表等分
```
from math import ceil


def divide(lst, size):
    if size <= 0:
        return [lst]
    return [lst[i * size: (i + 1) * size] for i in range(0, ceil(len(lst) / size))]


r = divide([1, 3, 5, 7, 9], 2)
print(r)

-> [[1, 3], [5, 7], [9]]


r = divide([1, 3, 5, 7, 9], 2)
print(r)

-> [[1, 3, 5, 7, 9]]

```

## 63 列表压缩-过滤空的
```
def filter_false(lst):
	return list(filter(bool, lst))
	
r = filter_false([None, 0, False, '', [], 'ok', [1,2]])
print(r)

```

## 64 最长的列表是哪个
```
def max_length(*lst):
	return max(*lst, key=lambda v: len(v))
	
r = max_length([1,2,3], [4,5,6,7], [8])
print(f'更长的列表是{r}')

-> 更长的列表是[4, 5, 6, 7]

```


## 65 求众数
```
def top1(lst):
    return max(lst, default='列表为空', key=lambda v: lst.count(v))


lst = [1, 3, 3, 2, 1, 1, 2]
r = top1(lst)
print(f'{lst}中出现次数最多的元素为：{r}')

-》 [1, 3, 3, 2, 1, 1, 2]中出现次数最多的元素为：1
```

## 66 多表之最
```
def max_lists(*lst):
	return max(max(*lst, key=lambda v : max(v)))
	
r = max_lists([1,2,3], [6,7,8], [4,5])
print(r)
->8

```


## 67 列表查重
```
def has_duplicates(lst):
	return len(lst) == len(set(lst))
	
x = [1,1,2,2,3,2,3,4,5,6]
y = [1,2,3,4,5]
has_duplicates(x) # False
has_duplicates(y) # True


```


## 68 列表反转
```
def reverse(lst):
    return lst[::-1]


x = [1, 1, 2, 2, 3, 2, 3, 4, 5, 6]
print(reverse(x))

-》 [6, 5, 4, 3, 2, 3, 2, 2, 1, 1]

```

## 69 浮点数等差数列
```
def rang(start, stop, n):
    start, stop, n = float('%.2f' % start), float('%.2f' % stop), int('%.d' % n)
    step = (stop - start) / n
    lst = [start]
    while n > 0:
        start, n = start + step, n - 1
        lst.append(round((start), 2))
    return lst




r = rang(1, 8, 10)
print(r)

C:\Python36\python.exe C:/mycode/awesome-python-io/run_test_code/run_基本功_python小例子.py
[1.0, 1.7, 2.4, 3.1, 3.8, 4.5, 5.2, 5.9, 6.6, 7.3, 8.0]
```


## 70 按条件分组
```
def bif_by(lst, f):
    return [[x for x in lst if f(x)], [x for x in lst if not f(x)]]


records = [25, 89, 31, 34]
r = bif_by(records, lambda x: x < 80)
print(r)
-》 [[25, 31, 34], [89]]

```

## 71 map 实现向量运算
```
# 多序列运算函数-map(fuction, iterabel, iterabel2)
lst1 = [1, 2, 3, 4, 5, 6]
lst2 = [3, 4, 5, 6, 3, 2]
r = list(map(lambda x, y: x * y + 1, lst1, lst2))
print(r)

C:\Python36\python.exe C:/mycode/awesome-python-io/run_test_code/run_基本功_python小例子.py
[4, 9, 16, 25, 16, 13]

```

## 72 值最大的字典
```
def max_pairs(dic):
    if len(dic) == 0:
        return dic
    max_val = max(map(lambda v: v[1], dic.items()))
    return [item for item in dic.items() if item[1] == max_val]


r = max_pairs({'a': -10, 'b': 5, 'c': 3, 'd': 5})
print(r)
C:\Python36\python.exe C:/mycode/awesome-python-io/run_test_code/run_基本功_python小例子.py
[('b', 5), ('d', 5)]

```


## 73 合并两个字典
```
def merge_dict(dict1, dict2):
    return {**dict1, **dict2}  # python3.5后支持一行代码实现合并字典


r = merge_dict({'a': 1, 'b': 2}, {'c': 3})
print(r)

C:\Python36\python.exe C:/mycode/awesome-python-io/run_test_code/run_基本功_python小例子.py
{'a': 1, 'b': 2, 'c': 3}


# 一行代码实现
# 一行代码实现
a = {'c': 3}
b = {'a': 1, 'b': 2}
a.update(b)
print(a)

```


## 74 topn字典
```
from heapq import nlargest


# 返回字典d 前n个最大值对应的键
def topn_dict(d, n):
    return nlargest(n, d, key=lambda k: d[k])


r = topn_dict({'a': 1, 'b': 8, 'c': 8, 'd': 11}, 3)
print(r)

C:\Python36\python.exe C:/mycode/awesome-python-io/run_test_code/run_基本功_python小例子.py
['d', 'b', 'c']
```

## 75 异位词
```
from collections import Counter


# 检查两个字符是否 相同字母异序词，简称：互为变位词

def anagram(str1, str2):
    return Counter(str1) == Counter(str2)


r = anagram('eleven+two', 'twelve+one')  # True 这是一对神器的变位词
print(r)
anagram('eleven', 'twelve')  # False

```


## 76 逻辑上合并字典
```
（1） 看73，修改 merged[‘x’]=10，dic1 中的 x 值不变，merged 是重新生成的一个新字典。
（2）但是，ChainMap 却不同，它在内部创建了一个容纳这些字典的列表。因此使用
ChainMap 合并字典，修改 merged[‘x’]=10 后，dic1 中的 x 值改变，如下所示：

from collections import ChainMap

dict1 = {'x': 1, 'y': 2}
dict2 = {'y': 3, 'z': 4}
merged2 = ChainMap(dict1, dict2)
print(merged2)

C:\Python36\python.exe C:/mycode/awesome-python-io/run_test_code/run_基本功_python小例子.py
ChainMap({'x': 1, 'y': 2}, {'y': 3, 'z': 4})

```


## 77 命名元组提高可读性
```
from collections import namedtuple

Point = namedtuple('Point', ['x', 'y', 'z'])  # 定义名为Point的元组，字段数组有x,y,z
lst = [Point(1.5, 2, 3.0), Point(-0.3, -1.0, 2.1), Point(1.3, 2.8, -2.5)]
print(lst[0].y - lst[1].y) # 3
```


## 78 样本抽样
```
# 使用sample抽样，如下例子从100个样本中随机抽样10个
from random import randint, sample

lst = [randint(0, 50) for _ in range(100)]
print(lst[:5])
lst_sample = sample(lst, 10)
print(lst_sample)

```


## 79 重洗数据集
```
# 使用shuffle 来冲洗数据集，值得注意"shuffle"是对lst就地(in place)洗牌，节省存储空间

from random import shuffle
from random import randint

lst = [randint(0, 50) for _ in range(100)]
print(lst)
shuffle(lst)
print(lst[:5])

```


## 80 10个均匀分布的坐标点
```
# random模块中的uniform(a,b)生成[a,b)内的一个随机数，如下生成10个均匀分布的二维坐标点
from random import uniform

r = [(uniform(0, 10), uniform(0, 10)) for _ in range(10)]
print(r)


```


## 81 10个高斯分布的坐标点
```
random模块中的gauss(u, sigma)生成均值为u, 标准差为sigma的满足高斯分布的值，如下生成10个二维坐标点，样本误差(y-2*x-1)满足均值为0，标准差为1的高斯分布：
from random import gauss

x = range(10)
y = [2 * xi + 1 + gauss(0, 1) for xi in x]
points = list(zip(x, y))
print(points)

```


## 82 chain高效串联多个容器对象
chain函数串联a和b，兼顾内存效率同时写法更加优雅
```
from itertools import chain

a = [1, 3, 4, 0]
b = (2, 4, 6)

for i in chain(a, b):
    print(i)


```


## 83 操作函数对象
```
def f():
	print('i\'m f')
	
def g():
	print('i\'m g')

[f,g][1]()

```


## 84 生成逆序序列
```
list(range(10, -1, -1))		# [10,9,8,7,6.5,4,3,2,1,0]

第三个参数为负时，表示从第一个参数开始递减，终止到第二个参数（不包括此边界）


```


## 85 函数的五类参数使用例子
python 五类参数：位置参数，关键字参数，默认参数，可变位置或关键字参数的使用
```
def f(a, *b, c=10, **d):
	print(f'a:{a}, b:{b}, c:{c}, d:{d}')
```
默认参数“c”不能位于可变关键字参数“d”后。


调用f：
In [10]: f(1,2,5,width=10,height=20)
a:1,b:(2, 5),c:10,d:{'width': 10, 'height': 20}

可变位置参数b实参后被解析为元组(2, 5)；而取得默认值10；d被解析为字典


再次调用f：
In [11]: f(a=1,c=12)
a:1,b:(),c:12,d:{}

a=1 传入时 a 就是关键字参数，b,d 都未传值，c 被传入 12，而非默认值。
注意观察参数 a, 既可以 f(1), 也可以 f(a=1) 其可读性比第一种更好，建议使
用 f(a=1)。如果要强制使用 f(a=1)，需要在前面添加一个星号:

```
def f(*, a, *b):
	print(f'a:{a}, b:{b}')
```
此 时 f(1) 调 用， 将 会 报 错：TypeError: f() takes 0 positional
arguments but 1 was given
只能 f(a=1) 才能 OK.
说明前面的 * 发挥作用，它变为只能传入关键字参数，那么如何查看这个参数的
类型呢？借助 python 的 inspect 模块：
```
for name, val in signature(f).parameters.items():
	print(name, val.kind)

a KEYWORD_ONLY
b VAR_KEYWORD
```
可看到参数 a 的类型为 KEYWORD_ONLY，也就是仅仅为关键字参数。
但是，如果 f 定义为
```
def f(a, *b):
	print(f'a:{a}, b:{b}')
```
查看参数类型：
```
for name, val in signature(f).parameters.items():
	print(name, val.kind)

a POSITIONAL_OR_KEYWORD
b VAR_POSITIONAL
```
可以看到参数 a 既可以是位置参数也可是关键字参数。

## 86 使用slice对象
生成关于蛋糕的序列cake 1:
```
cake1 = list(range(5, 0, -1))
b  = cake1[1:10:2]
print(b)
->[4, 2]
print(cake1)
-> [5, 4, 3, 2, 1]

再生成一个序列：
from random imporr randint
	cake2 = [randint(1, 100) for _ in range(100)]
	# 同样以间隔为2切前10个元素， 得到切片d
	d = cake2[1:10:2]
print(d)
-> [75, 33, 63, 93, 15]

```

你看，我们使用同一种切法，分别切开两个蛋糕 cake1,cake2. 后来发现这种切法极
为经典，又拿它去切更多的容器对象。
那么，为什么不把这种切法封装为一个对象呢？于是就有了 slice 对象。
定义 slice 对象极为简单，如把上面的切法定义成 slice 对象：
```
perfect_cake_slice_way = slice(1,10,2) # 去切 cake1
cake1_slice = cake1[perfect_cake_slice_way]
cake2_slice = cake2[perfect_cake_slice_way]
In [11]: cake1_slice
Out[11]: [4, 2]
In [12]: cake2_slice
Out[12]: [75, 33, 63, 93, 15]

```

与上面的结果一致。
对于逆向序列切片，slice 对象一样可行：
```
a = [1,3,5,7,9,0,3,5,7]
a_ = a[5:1:-1]
named_slice = slice(5,1,-1)
a_slice = a[named_slice]
In [14]: a_
Out[14]: [0, 9, 7, 5]
In [15]: a_slice
Out[15]: [0, 9, 7, 5]
```
频繁使用同一切片的操作可使用 slice 对象抽出来，复用的同时还能提高代码可读
性。

## 上面的基础实际为86个

# Python 字符串和正则





【环境】
win10_x64 + python3.6.5


【Me】
https://github.com/Valuebai/
https://valuebai.github.io/

【参考】
1、出处：https://github.com/jackzhenguo/python-small-examples